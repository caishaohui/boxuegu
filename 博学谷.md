# 博学谷项目
## 目录结构
## jquery事件回调函数有一个参数：事件对象e 
+ $('btn').on('click',funciotn(e){
1. 阻止页面跳转
+ e.preventDefault();阻止事件的默认行为,就可以阻止页面的跳转
+ e.stropPropagation();阻止事件冒泡

2. returan false阻止默认行为就可以实现阻止页面跳转
  })

### arttemplate基本使用
+ 下载arttemplate
+ 页面中引用arttemplate
+ 编写模板内容：
    var tpl="hi,{{value}}";
+ 编译模板内容：
    var html=template.render(tpl,{ value:100 });//正常编译完成之后的内容存放在html中
    html值为hi,100

### API比较
template("script的id",数据);//-->弊端：一定要在页面中准备无数个模板

template.render("模板字符串",数据);

template("模板文件路径",数据);


## 重要知识点
1. 将表单数据进行序列化
       要想获取序列化的数据，该表单数据一定要有name属性,然后通过 var formData=$(this).serialize();得到name的值
 ##### 2. 跳转到其他页面index.html
      location.href="index.html";
3. 阻止页面跳转，就是阻止submit事件的默认行为
          return false;
4. requireJS中的 text.js插件的使用
        text的使用:,主要用于html结构模板作为template模板参数使用.
        使用方法:要加!号, text!index.html
5. requireJS方法:
    如果一个js文件不支持AMD模块规范(比如bootstrap),但他又依赖模块(jquery),通过下列方式解决
    加shim这样的设置,是在读取bootstrap的时候一定会优先读取jquery,等jquery读取完毕才会读取bootstrap
        require.config({
            baseUrl:"./lib" , //指定路径,
            paths:{ 
                //路径不需要后缀,最终文件路径会和baseUrl拼接,也就是"./lib/js/jquery-2.1.4""
                jquery:"js/jquery-2.1.4",
                bootstrap:'路径/bootstrap'
                --->重点:用来读取html文件的
                text:'lib/text'
                //配置arttemplate模板引擎路径
                template:'lib/template'
            },
            shim:{
                //这里的bootstrap是上面paths的bootstrap
                bootstrap:{
                    //这里的jquery是上面paths的jquery
                    deps:['jquery']
                }
            }
         })
#####6. trigger方法模拟用户点击
        $('btn').trigger('click')会触发按钮的click事件

## http状态码
+ 登录获取其他接口出现：503/501这样的状态码-->没有联网
+ index.html中的请求出现401：授权失败、验证失败-->没有正确的用户名和密码-->没有登录过

## 数据序列化和反序列化 
#####1.JSON.stringify()：将对象序列化为JSON字符串格式
     var string=JSON.stringify({name:'张三'})  log(string)-->"{"name":"张三"}"
#####2.JSON.parse()：将JSON字符串反序列化为对象格式
     var string=JSON.parse('{"name":"张三"}') -->  {name:'张三'} 
+ 序列化目的: 因为设置数据缓存值为字符串,传对象,其他类型解析出来的是[object object]等值,就不能获取原值,所以要序列化

##数据缓存 跨页面访问数据的方式
### h5：localStorage/sessionStorage
+ 这两种方式的区别：数据缓存时间不同
    - localStorage缓存的数据是永久保存
    - sessionStorage缓存的数据在关闭浏览器之后就会消失
+ API：
    - sessionStorage.setItem("键","值");
        - `备注`：值表面上是可以接收任意数据类型的值，然而如果存储了非字符串类型的值，最终存储的时候，会把该值转换为字符串类型
    - sessionStorage.getItem("键")：获取该键对应的值

    - sessionStorage.removeItem：清除指定的键值
    - sessionStorage.clear：清空所有的数据
      MDN: https://developer.mozilla.org/zh-CN/docs/Web/API/Window/sessionStorage

##数据缓存 跨页面访问数据的方式 (兼容性好)  
##  cookie：浏览器中的技术(王牌劲旅)
1. 原生js写法 不用jquery
      --
    会话cookie：当一个会话结束时，这样的cookie就没了
    存储一个键值：
    document.cookie="id=666";
    获取键值：
    console.log(document.cookie);//打印出当前域名下面的所有的cookie值
    持久cookie：这样的cookie能够持续一段时间
    document.cookie="name=ccc;expires="+new Date("2017-08-20 08:00:00");
    console.log(document.cookie);
#### 2. 基于jquery的cookie插件
      $.cookie中expires可以是Date类型的数据，也可以是数字类型的数据，如果是数字类型表示多少天"后过期
    1、设置值
    $.cookie("age", 18);
    $.cookie("gender", "女", {expires: 1});//cookie值将会在一天后过期
    $.cookie("length", 160, {expires: 0.5});//cookie值将会在半天后过期
    2、获取值
    alert($.cookie("age"));
    alert($.cookie("gender"));
    alert($.cookie("length"));
    3、移除指定的cookie值
    $.removeCookie("length");
+ cookie不仅可以在浏览器中读写，也可以在服务器中读写
+ cookie不能跨域
+ cookie不能存储安全性较高的内容：比如用户密码
    博客园 

     - `备注`：值表面上是可以接收任意数据类型的值，然而如果存储了非字符串类型的值，最终存储的时候，会把该值转换为字符串类型
      :http://www.cnblogs.com/webcome/p/5470975.html


## 获取表单的序列化数据
#### $("form").serialize()
+ 表单提交要异步 所有要阻止submit的默认同步跳转 用return  false方法, 
+ 表单提交 $(模板).on('submit','form',fn)

## http状态码
+ 登录获取其他接口出现：503/501这样的状态码-->没有联网
+ index.html中的请求出现401：授权失败、验证失败-->没有正确的用户名和密码-->没有登录过

## 隐藏域：
+ 隐藏域：用户看不到，但是隐藏域中的数据是可以提交到服务器中的,可以序列化他的name ,value值
+ 一般在表单中如 :
#### <input type="hidden">设置type为hidden就看不到了

## 一种特殊的函数表达式
    var fn=function(){}
    fn();
    
    var fn2=function fn3(){
        //在函数体内部fn3和fn2和arguments.callee都表示当    前函数体
    };
    fn2();
    //函数外部不能使用fn3()调用
    这几个fn,fn2,fn3,arguments.callee都表示当前函数体

## 事件绑定
    var $1=$("body");
    var $2=$("body");
    console.log($1==$2);//false
    console.log($1[0]==$2[0]);//true
    $1和$2不是同一个dom元素所以对事件绑定的时候要保存值操作
    
    var input="<input type='button' value='按钮'/>";
    a、$(input)这一段话中把input这个字符串转换为DOM元素了，然后把该DOM元素放到该jquery对象中，后续的事件绑定是绑定给了这个DOM元素
    
    $(input).on("click",function(){
        alert("事件绑定");
    });
    b、append(input)这一段话中append方法内部会自动的把input字符串转换为DOM元素 
    
    $("body").append(input);

 +   a、b这2次转换结果并不是同一个DOM元素，所以会出现事件绑定失败的情况
    a元素有事件绑定
    b元素没有事件绑定，b元素出现在了页面中

解决方案1：
    var input="<input type='button' value='按钮'/>";
    var $input=$(input).on("click",function(){
        alert("事件绑定");
    });
    
    $("body").append($input);

## 字符串用法 
+ var str='aaa=c;xx=aa;'
#### str.indexOf('字符串',从那开始检索--数字    可不填)
+ 如果要检索的字符串值没有出现，则该方法返回 -1; 有则返回坐标索引值

## 备注：下拉框的使用
+ 下拉框的name值应该设定在select标签中，value值存在于每一个option标签中
+ option的使用
    - option有文本，文本是给用户看的
    - option有value，value是用来提交表单的
+ 给提交按钮绑定事件(submit)
    - 应该注意：阻止事件的默认行为（同步的表单-->异步的表单）
    - 通过ajax方式的获取表单中的数据，把数据提交到服务器中
        -- $(...).serialize()    //-->数据一定要有name属性，name属性怎么来？根据文档来一一对应
            -- 文本框/文本域 直接添加name
            -- 单选框、复选框：每一项都应该有name
            -- 下拉框：select设置name，option设置value

## 编辑分类ajax嵌套之后的数据处理实现思路：

1. 有了嵌套，第一个嵌套res存放顶级分类信息，第二个嵌套resEdit存放原来的信息
2. 把顶级分类信息放到下拉框中，这段逻辑之前就已经实现了(res)，所以只需要把resEdit中的信息也放进去就好了
3. 为了把resEdit中的信息放进去，我们通过把resEdit中的result属性存储在res中：res.obj=resEdit.result;原理就是把resEdit.result的内存地址复制给res.obj一份
4. 后续在模板中通过：obj.cg_name就相当于：resEdit.result.cg_name，其他的表单也与其类似

## jquery插件
+ 要编写一个像bootstrap.js这样的jquery插件，本质上就是给$.fn添加一个方法

+ $：jQuery
+ $.fn就是：jQuery.prototype

+ 举例：
```js
//编写
$.fn.myModal=function(){};
//调用
$("div").myModal();
```
return this 这个this是$,是为了链式编程

## jQuery链式编程
```js
var $1=$("body").css({color:"red"}).myModal();




首页菜单的切换
1. 通过给不同的菜单添加了不同的类名
2. 事件触发的时候，判断该菜单是否有指定的类名，根据不同的类名实现不同的功能
    $("div").hasClass("hover")


##  联动下拉框实现原理
需求：根据选中的前一个下拉框的值，获取对应的【后一个下拉框】中的数据
思路：
    1、获取第一个下拉框的值-->给下拉框绑定change事件，事件触发的时候，获取下拉框的value
    2、根据value获取到指定的数据，把数据加载到【后一个下拉框】中


## $.extend  实现了混入继承(拷贝继承)
参数1：目标对象-->接受数据的对象
参数2、参数3.。。。。。。。：源对象，提供数据的对象

1. 将一个对象中的属性拷贝到另一个对象中
var o1={num:100,age:50,gender:"男"};
var o2={};
$.extend(o2,o1);

//给o2添加了length/height/width
$.extend(o2,{length:100},{height:30},{width:60})

## uploadify
 + 上传文件,图片等.

 + 使用uploadify
    - 导入uploadify.css
    - 导入jquery-2.1.4.js
    - 导入uploadify.js 依赖jquery,不支持amd规范
    - body中要有,一定是id
    <input type="file" id="file_upload_1">
    - 初始化 $("#file_upload_1").uploadify({ 要配置的参数})

 + 官网 http://www.uploadify.com/   
    

## UEidtor
+ ueditor是什么？
UEidtor是由百度前端团队开发的一款富文本编辑器
   
CKEditor是老外的官网: https://ckeditor.com/

+ 常见的富文本编辑器
    - ueditor
    - ckeditor

+ 使用ueditor
    - 导入ueditor.config.js
    - 导入ueditor.all.js 依赖配置shim  ueditor.config.js

+ 项目中使用
    - 在ueditor.config.js中修改ueditor文件夹路径：window.UEDITOR_HOME_URL = "/assets/ueditor/";
    - 在ueditor.config.js中修改zIndex属性，超过模态框的zindex(>1050)
    
    - 配置ueditor.config.js/ueditor.all.js的路径
    - 通过shim解决2个js文件的依赖
    - 在需要渲染编辑器的模块，导入指定的js
    - 在需要渲染编辑器的页面模板中，添加一段代码
    <script id="ueContainer" name="tc_introduce" type="text/plain"></script>
    - 当页面已经加载完毕之后，初始化编辑器：

    先删除富文本编辑器的id,是为了解决第二次点击富文本编辑器不出现的bug
     UE.delEditor('ueContainer');

    var ue=UE.getEditor('ueContainer');
    - 当编辑器初始化完毕后，加载原来的自我介绍
    ```js
        ue.ready(function(){
            ue.setContent(res.result.tc_introduce);
        })
    ```
    官网 :   http://ueditor.baidu.com/website/

## 图表软件echarts 
echarts     百度
highcharts  老外
+ 使用 ;
   1. 引入echarts.min.js 支持amd规范
   2.  <div id="main" style="width: 600px;height:400px;"></div>
   3. js中初始化,获取元素
    基于准备好的dom，初始化echarts实例,不一定要id
    var main=document.getElementById('main');
    var myChart = echarts.init(main);
     指定图表的配置项和数据
    var option = { 
        配置参数
    }
     使用刚指定的配置项和数据显示图表。
    myChart.setOption(option);
+ 入门：文档-->教程

+ 参数：文档-->配置项手册
+ 案例：实例-->官方实例

官网 : http://echarts.baidu.com/

## map方法循环数组return返回新数组

var count=arr.count(function(v,i){
    return v.name
})

